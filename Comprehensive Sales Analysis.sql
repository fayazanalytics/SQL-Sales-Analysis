#What is the total quantity of products sold in the month of May 2022?

SELECT SUM(od.quantity) AS total_quantity
FROM orders o 	
INNER JOIN order_details od ON o.order_id = od.order_id
INNER JOIN products p ON od.product_id = p.product_id
WHERE o.order_date >= '2022-05-01' AND o.order_date < '2022-06-01';

#What is the total revenue generated by the category "Electronics" in the month of December 2022?

SELECT SUM(od.quantity * od.unit_price) AS total_revenue
FROM orders o
INNER JOIN order_details od ON o.order_id = od.order_id
INNER JOIN products p ON od.product_id = p.product_id
INNER JOIN categories c ON p.category_id = c.category_id
WHERE c.category_name = 'Electronics' AND o.order_date >= '2022-12-01' AND o.order_date < '2023-01-01';

#Write a query to return the name and email of all customers who have placed an order in the month of May and have ordered a product with a price greater than $100. Which of the following options returns the correct result?

SELECT c.name, c.email
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
INNER JOIN order_details od ON o.order_id = od.order_id
INNER JOIN products p ON od.product_id = p.product_id
WHERE MONTH(o.order_date) = 5 AND p.price > 100;

#Write a query to return the name and address of all customers who have ordered a product from the category 'Electronics' and whose order status is 'Delivered'. Which of the following options returns the correct result?

SELECT c.name, c.address
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
INNER JOIN order_details od ON o.order_id = od.order_id
INNER JOIN products p ON od.product_id = p.product_id
INNER JOIN categories cat ON p.category_id = cat.category_id
WHERE cat.category_name = 'Electronics' AND o.order_status = 'Delivered';

#Write a query to return the name and email of all customers who have placed an order, and also include customers who haven't placed any orders yet. Which of the following options returns the correct result?

SELECT c.name, c.email
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id;

#Write a query to return the product name and price of all products, including products that have no orders placed yet. Which of the following options returns the correct result?

SELECT p.product_name, p.price
FROM products p
RIGHT JOIN order_details od ON p.product_id = od.product_id;


#Write a query to return the name and email of all customers who have placed an order for a product with a price greater than $100. Include customers who have not placed any orders. How many entries of such details are there?

SELECT c.name, c.email
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN order_details od ON o.order_id = od.order_id
LEFT JOIN products p ON od.product_id = p.product_id AND p.price > 100;

#Write a query to return the name and address of all customers who have placed an order for a product in the category 'Electronics', including customers who have not placed any orders. How many such rows are there?

SELECT c.name, c.address
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN order_details od ON o.order_id = od.order_id
LEFT JOIN products p ON od.product_id = p.product_id
LEFT JOIN categories cat ON p.category_id = cat.category_id AND cat.category_name = 'Electronics';


#Write a query to return all department names along with the number of employees in each department, including departments with no employees. Which of the following options correctly identifies the departments with no employees?



#Write a query to return the names of all customers who have not placed an order.

SELECT departments.department_name, COUNT(employees.department_id) AS employee_count
FROM departments
LEFT JOIN employees ON departments.department_id = employees.department_id
GROUP BY departments.department_name;

#Write a query to return the customer name and order date for all orders, including those with no corresponding customer or product data. Which of the following options returns the correct result?

SELECT c.name, o.order_date
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN order_details od ON o.order_id = od.order_id
RIGHT JOIN products p ON od.product_id = p.product_id
WHERE c.customer_id IS NULL OR p.product_id IS NULL;

#Consider two tables, customers and orders, with a Full Outer Join on the customer_id column. how many customers didn't place any order?

SELECT COUNT(c.customer_id)
FROM customers c
LEFT JOIN orders o
ON c.customer_id = o.customer_id
WHERE o.customer_id IS NULL;

#Write a query to return the name of all employees and their corresponding skip-level manager's name. Which of the following options represents the correct number of self-joins required to achieve this?

SELECT e1.name AS employee_name, e2.name AS skip_level_manager_name
FROM employees e1
INNER JOIN employees e2 ON e1.manager_id = e2.emp_id
INNER JOIN employees e3 ON e2.manager_id = e3.emp_id;

#Write a query to return the name of all employees and their corresponding manager's name. Which of the following options represents the correct number of self-joins required to achieve this, assuming that the employee table contains a foreign key column 'manager_id' which references the employee_id of the same table?

SELECT e.name AS employee_name, m.name AS manager_name
FROM employees e
JOIN employees m ON e.manager_id = m.emp_id;

#Rank the customers based on:
#Total purchasing they have done in terms of amount in desc order:

SELECT Customer_Id, TotalAmountPaid,
RANK() OVER(ORDER BY TotalAmountPaid DESC) AS _Rank,
DENSE_RANK() OVER(ORDER BY TotalAmountPaid DESC) AS DenseRank
FROM (SELECT Customer_Id,
      SUM(Amount_Paid) AS TotalAmountPaid 
      FROM ProductSalesFact 
      GROUP BY Customer_Id) AS T;
      
#Total quantities they have purchased by descending order
SELECT Customer_Id, TotalQuantityPurchased,
RANK() OVER(ORDER BY TotalQuantityPurchased DESC) AS _Rank,
DENSE_RANK() OVER(ORDER BY TotalQuantityPurchased DESC) AS DenseRank
FROM (SELECT Customer_Id,
      SUM(Quantity) AS TotalQuantityPurchased
      FROM ProductSalesFact 
      GROUP BY Customer_Id) AS T;
      
#Identify the top 1 ranking product/s within each product category by their Price

SELECT *
FROM
(
SELECT Product_Id, Price, Category_Id,
DENSE_RANK() OVER(PARTITION BY Category_Id ORDER BY Price DESC) AS _rank
FROM ProductDim) AS T
WHERE _rank = 1;

#Identify the top 1 ranking product/s within each product category by number of days they are in inventory from the current date.

SELECT *
FROM
(
SELECT Product_Id, DATEDIFF(NOW(),In_Inventory) TotalDays, Category_Id,
DENSE_RANK() OVER(PARTITION BY Category_Id ORDER BY DATEDIFF(NOW(),In_Inventory) DESC) AS _rank
FROM ProductDim) AS T
WHERE _rank = 1;

# Rank the complaints that are not resolved by their number of days in top to bottom order.

SELECT Complaint_Name, DATEDIFF(NOW(),Complaint_Date) AS TotalDaysNotResolved, RANK() OVER(PARTITION BY Complaint_Name ORDER BY DATEDIFF(NOW(),Complaint_Date) DESC) AS _rank FROM Complaints WHERE Resolved != 'Resolved';

#Compare the total purchase by amount that happened for each Usage type on a week by week basis.Remove records where we have null values on past or future values.

SELECT *,
TotalPurchase - Past AS RevenueFromLastWeek
FROM
(
SELECT *,
LAG(TotalPurchase) OVER(PARTITION BY Cust_Usage ORDER BY _week) AS Past,
LEAD(TotalPurchase) OVER(PARTITION BY Cust_Usage ORDER BY _week) AS Future
FROM (SELECT Cust_Usage,
     EXTRACT(WEEK FROM DateofPurchase) as _week,
     SUM(Amount_Paid) AS TotalPurchase
     FROM ProductSalesFact
     GROUP BY Cust_Usage, _week) AS T) AS T
     WHERE Past IS NOT NULL AND Future IS NOT NULL;
     
#Compare the total number of complaints resolved on a week by week basis [include only past values]? 

SELECT *,
LAG(TotalComplaints) OVER(PARTITION BY Resolved ORDER BY _week) AS Past
FROM (SELECT Resolved,
     EXTRACT(WEEK FROM Complaint_Date) as _week,
     COUNT(*) AS TotalComplaints
     FROM Complaints
     GROUP BY Resolved, _week) AS T;
     
#Get the number of customers that you witness week-by-week on your platform for each usage type including past and future values.

SELECT *,
LAG(TotalCustomers) OVER(PARTITION BY Cust_Usage ORDER BY _week) AS Past,
LEAD(TotalCustomers) OVER(PARTITION BY Cust_Usage ORDER BY _week) AS Future
FROM (SELECT Cust_Usage,
     EXTRACT(WEEK FROM DateofPurchase) as _week,
     COUNT(*) AS TotalCustomers
     FROM ProductSalesFact
     GROUP BY Cust_Usage, _week) AS T
     


